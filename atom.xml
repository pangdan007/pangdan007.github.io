<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Elbert的博客</title>
  <icon>https://www.gravatar.com/avatar/c60bfe796adec825aebfa39f783afb91</icon>
  <subtitle>乐观好学</subtitle>
  <link href="http://pangdan007.github.io/atom.xml" rel="self"/>
  
  <link href="http://pangdan007.github.io/"/>
  <updated>2020-11-14T07:42:43.033Z</updated>
  <id>http://pangdan007.github.io/</id>
  
  <author>
    <name>EB</name>
    <email>741731647@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>互质判别法</title>
    <link href="http://pangdan007.github.io/2020/11/14/%E4%BA%92%E8%B4%A8%E5%88%A4%E5%88%AB%E6%B3%95/"/>
    <id>http://pangdan007.github.io/2020/11/14/%E4%BA%92%E8%B4%A8%E5%88%A4%E5%88%AB%E6%B3%95/</id>
    <published>2020-11-14T07:33:35.337Z</published>
    <updated>2020-11-14T07:42:43.033Z</updated>
    
    <content type="html"><![CDATA[<h1 id="两个数互质的判别方法："><a href="#两个数互质的判别方法：" class="headerlink" title="两个数互质的判别方法："></a>两个数互质的判别方法：</h1><h5 id="（1）两个不同的质数一定是互质数。"><a href="#（1）两个不同的质数一定是互质数。" class="headerlink" title="（1）两个不同的质数一定是互质数。"></a>（1）两个不同的质数一定是互质数。</h5><pre><code>        例如，2与7、13与19。</code></pre><h5 id="（2）一个质数，另一个不为它的倍数，这两个数为互质数。"><a href="#（2）一个质数，另一个不为它的倍数，这两个数为互质数。" class="headerlink" title="（2）一个质数，另一个不为它的倍数，这两个数为互质数。"></a>（2）一个质数，另一个不为它的倍数，这两个数为互质数。</h5><pre><code>        例如，3与10、5与 26。</code></pre><h5 id="（3）1不是质数也不是合数，它和任何一个自然数（1本身除外）在一起都是互质数。"><a href="#（3）1不是质数也不是合数，它和任何一个自然数（1本身除外）在一起都是互质数。" class="headerlink" title="（3）1不是质数也不是合数，它和任何一个自然数（1本身除外）在一起都是互质数。"></a>（3）1不是质数也不是合数，它和任何一个自然数（1本身除外）在一起都是互质数。</h5><pre><code>        如1和9908。</code></pre><h5 id="（4）相邻的两个自然数是互质数。"><a href="#（4）相邻的两个自然数是互质数。" class="headerlink" title="（4）相邻的两个自然数是互质数。"></a>（4）相邻的两个自然数是互质数。</h5><pre><code>        如 15与 16。</code></pre><h5 id="（5）相邻的两个奇数是互质数。"><a href="#（5）相邻的两个奇数是互质数。" class="headerlink" title="（5）相邻的两个奇数是互质数。"></a>（5）相邻的两个奇数是互质数。</h5><pre><code>        如 49与 51。</code></pre><h5 id="（6）较大数是质数的两个数是互质数。"><a href="#（6）较大数是质数的两个数是互质数。" class="headerlink" title="（6）较大数是质数的两个数是互质数。"></a>（6）较大数是质数的两个数是互质数。</h5><pre><code>        如97与88。</code></pre><h5 id="（7）两个数都是合数（二数差又较大），较小数所有的质因数，都不是较大数的约数，这两个数是互质数。"><a href="#（7）两个数都是合数（二数差又较大），较小数所有的质因数，都不是较大数的约数，这两个数是互质数。" class="headerlink" title="（7）两个数都是合数（二数差又较大），较小数所有的质因数，都不是较大数的约数，这两个数是互质数。"></a>（7）两个数都是合数（二数差又较大），较小数所有的质因数，都不是较大数的约数，这两个数是互质数。</h5><pre><code>        如357与715，357=3×7×17，而3、7和17都不是715的约数，这两个数为互质数。</code></pre><h5 id="（8）两个数都是合数（二数差较小），这两个数的差的所有质因数都不是较小数的约数，这两个数是互质数。"><a href="#（8）两个数都是合数（二数差较小），这两个数的差的所有质因数都不是较小数的约数，这两个数是互质数。" class="headerlink" title="（8）两个数都是合数（二数差较小），这两个数的差的所有质因数都不是较小数的约数，这两个数是互质数。"></a>（8）两个数都是合数（二数差较小），这两个数的差的所有质因数都不是较小数的约数，这两个数是互质数。</h5><pre><code>        如85和78。85－78=7，7不是78的约数，这两个数是互质数。</code></pre><h5 id="（9）两个数都是合数，较大数除以较小数的余数（不为“0”且大于“-1”）的所有质因数，都不是较小数的约数，这两个数是互质数。"><a href="#（9）两个数都是合数，较大数除以较小数的余数（不为“0”且大于“-1”）的所有质因数，都不是较小数的约数，这两个数是互质数。" class="headerlink" title="（9）两个数都是合数，较大数除以较小数的余数（不为“0”且大于“ 1”）的所有质因数，都不是较小数的约数，这两个数是互质数。"></a>（9）两个数都是合数，较大数除以较小数的余数（不为“0”且大于“ 1”）的所有质因数，都不是较小数的约数，这两个数是互质数。</h5><pre><code>        如 462与 221        462÷221=2……20，        20=2×2×5。        2、5都不是221的约数，这两个数是互质数。</code></pre><h5 id="（10）减除法。"><a href="#（10）减除法。" class="headerlink" title="（10）减除法。"></a>（10）减除法。</h5><pre><code>        如255与182。        255－182=73，观察知 73182。        182－（73×2）=36，显然 3673。        73－（36×2）=1，        （255，182）=1。        所以这两个数是互质数。</code></pre><h5 id="三个或三个以上自然数互质有两种不同的情况：一种是这些成互质数的自然数是两两互质的。"><a href="#三个或三个以上自然数互质有两种不同的情况：一种是这些成互质数的自然数是两两互质的。" class="headerlink" title="三个或三个以上自然数互质有两种不同的情况：一种是这些成互质数的自然数是两两互质的。"></a>三个或三个以上自然数互质有两种不同的情况：一种是这些成互质数的自然数是两两互质的。</h5><pre><code>        如2、3、5。</code></pre><h5 id="另一种不是两两互质的。"><a href="#另一种不是两两互质的。" class="headerlink" title="另一种不是两两互质的。"></a>另一种不是两两互质的。</h5><pre><code>        如6、8、9。</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;两个数互质的判别方法：&quot;&gt;&lt;a href=&quot;#两个数互质的判别方法：&quot; class=&quot;headerlink&quot; title=&quot;两个数互质的判别方法：&quot;&gt;&lt;/a&gt;两个数互质的判别方法：&lt;/h1&gt;&lt;h5 id=&quot;（1）两个不同的质数一定是互质数。&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>约分函数</title>
    <link href="http://pangdan007.github.io/2020/10/06/%E7%BA%A6%E5%88%86%E5%87%BD%E6%95%B0/"/>
    <id>http://pangdan007.github.io/2020/10/06/%E7%BA%A6%E5%88%86%E5%87%BD%E6%95%B0/</id>
    <published>2020-10-06T15:06:54.812Z</published>
    <updated>2020-10-06T15:08:41.692Z</updated>
    
    <content type="html"><![CDATA[<h1 id="约分算法"><a href="#约分算法" class="headerlink" title="约分算法"></a>约分算法</h1><p>今天在刷题的时候偶然看到一个对有理数约分的算法，觉得很有必要记录下来，整合代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rational</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> ra;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> rb;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">gdc</span><span class="params">(<span class="keyword">long</span> a,<span class="keyword">long</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(b==<span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line"><span class="keyword">return</span> gdc(b,a%b);           <span class="comment">//约分算法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Rational</span><span class="params">(<span class="keyword">long</span> a,<span class="keyword">long</span> b)</span> </span>&#123;</span><br><span class="line">ra = a;</span><br><span class="line">rb = b;</span><br><span class="line"><span class="keyword">long</span> k = gdc(ra,rb);         <span class="comment">//构造有理数的时候直接约分</span></span><br><span class="line"><span class="keyword">if</span>(k&gt;<span class="number">1</span>) &#123;</span><br><span class="line">ra /= k;       <span class="comment">//注意这里是ra</span></span><br><span class="line">rb /= k;       <span class="comment">//一开始写成a导致没有约分</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(rb==<span class="number">1</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span> + ra;</span><br><span class="line"><span class="keyword">return</span> ra + <span class="string">&quot;/&quot;</span> + rb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Rational x = <span class="keyword">new</span> Rational(<span class="number">6</span>, <span class="number">8</span>);</span><br><span class="line">System.out.println(x.toString());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;约分算法&quot;&gt;&lt;a href=&quot;#约分算法&quot; class=&quot;headerlink&quot; title=&quot;约分算法&quot;&gt;&lt;/a&gt;约分算法&lt;/h1&gt;&lt;p&gt;今天在刷题的时候偶然看到一个对有理数约分的算法，觉得很有必要记录下来，整合代码如下。&lt;/p&gt;
&lt;figure class=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>2013蓝桥T4</title>
    <link href="http://pangdan007.github.io/2020/10/06/2013%E8%93%9D%E6%A1%A5T4/"/>
    <id>http://pangdan007.github.io/2020/10/06/2013%E8%93%9D%E6%A1%A5T4/</id>
    <published>2020-10-06T14:59:33.823Z</published>
    <updated>2020-10-06T15:04:25.725Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2013-蓝桥B-T4"><a href="#2013-蓝桥B-T4" class="headerlink" title="2013 蓝桥B T4"></a>2013 蓝桥B T4</h1><p> 题目：黄金分割数0.61803… 是个无理数，这个常数十分重要，在许多工程问题中会出现。有时需要把这个数字求得很精确。<br>    对于某些精密工程，常数的精度很重要。也许你听说过哈勃太空望远镜，它首次升空后就发现了一处人工加工错误，对那样一      个庞然大物，其实只是镜面加工时有比头发丝还细许多倍的一处错误而已，却使它成了“近视眼”!!<br>    言归正传，我们如何求得黄金分割数的尽可能精确的值呢？有许多方法。<br>    比较简单的一种是用连分数：</p><pre><code>              1黄金数 = ---------------------                    1         1 + -----------------                      1             1 + -------------                        1                 1 + ---------                      1 + ...                    这个连分数计算的“层数”越多，它的值越接近黄金分割数。请你利用这一特性，求出黄金分割数的足够精确值，要求四舍五入到小数点后100位。小数点后3位的值为：0.618小数点后4位的值为：0.6180小数点后5位的值为：0.61803小数点后7位的值为：0.6180340</code></pre><p>   （注意尾部的0，不能忽略）<br>你的任务是：写出精确到小数点后100位精度的黄金分割值。<br>注意：尾数的四舍五入！ 尾数是0也要保留！<br>显然答案是一个小数，其小数点后有100位数字，请通过浏览器直接提交该数字。<br>注意：不要提交解答过程，或其它辅助说明类的内容。</p><p>思路：把这个黄金连分数转换成分数的形式，首先只看第一个分数线，那么此时黄金连分数是1/2，然后再向下考虑一层，为2/3，以此类推，3/5，5/8…归纳起来就是要求斐波那契数列中连续两项的比值，并要求足够精确，即尽量找斐波那契数列靠后面的任意两项，求他俩的比值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">       BigInteger a = BigInteger.ONE;</span><br><span class="line">BigInteger b = BigInteger.ONE;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; <span class="number">600</span>; i++) &#123;<span class="comment">//600的原因是要尽可能大，大到</span></span><br><span class="line">                               <span class="comment">//当结果的小数点前100位</span></span><br><span class="line">                               <span class="comment">//不再变化为止</span></span><br><span class="line">BigInteger t = b;</span><br><span class="line">b = a.add(b);</span><br><span class="line">a = t;<span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">BigDecimal devide = <span class="keyword">new</span> BigDecimal(a,<span class="number">110</span>).divide(<span class="keyword">new</span> BigDecimal(b,<span class="number">110</span>),BigDecimal.ROUND_HALF_DOWN);</span><br><span class="line">System.out.println(devide.toPlainString().substring(<span class="number">0</span>,<span class="number">103</span>));</span><br></pre></td></tr></table></figure><p>根据题目要求，要精确到小数点后100位，而double型只能保证十进制小数点后15位有效精度和第16位的部分精度，因此这里可以直接使用Java API中的BigInteger和BigDecimal。</p><h2 id="BigInteger"><a href="#BigInteger" class="headerlink" title="BigInteger"></a>BigInteger</h2><p>表示任意大小的整数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BigInteger bi = <span class="keyword">new</span> BigInteger(<span class="string">&quot;1234567890&quot;</span>);</span><br><span class="line">System.out.println(bi.pow(<span class="number">5</span>)); <span class="comment">// 2867971860299718107233761438093672048294900000</span></span><br></pre></td></tr></table></figure><p>对BigInteger做运算的时候，只能使用实例方法，例如，加法运算：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BigInteger i1 = <span class="keyword">new</span> BigInteger(<span class="string">&quot;1234567890&quot;</span>);</span><br><span class="line">BigInteger i2 = <span class="keyword">new</span> BigInteger(<span class="string">&quot;12345678901234567890&quot;</span>);</span><br><span class="line">BigInteger sum = i1.add(i2); <span class="comment">// 12345678902469135780</span></span><br></pre></td></tr></table></figure><p><a href="https://docs.oracle.com/javase/7/docs/api/java/math/BigInteger.html">更多BigInteger方法戳这里</a></p><h2 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h2><p>BigDecimal可以表示一个任意大小且精度完全准确的浮点数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal bd = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;123.4567&quot;</span>);</span><br><span class="line">System.out.println(bd.multiply(bd)); <span class="comment">// 15241.55677489</span></span><br></pre></td></tr></table></figure><p>BigDecimal用scale()表示小数位数，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal d1 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;123.45&quot;</span>);</span><br><span class="line">BigDecimal d2 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;123.4500&quot;</span>);</span><br><span class="line">BigDecimal d3 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;1234500&quot;</span>);</span><br><span class="line">System.out.println(d1.scale()); <span class="comment">// 2,两位小数</span></span><br><span class="line">System.out.println(d2.scale()); <span class="comment">// 4</span></span><br><span class="line">System.out.println(d3.scale()); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>在比较两个BigDecimal的值是否相等时，要特别注意，使用equals()方法不但要求两个BigDecimal的值相等，还要求它们的scale()相等，必须使用compareTo()方法来比较，它根据两个值的大小分别返回负数、正数和0，分别表示小于、大于和等于。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal d1 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;123.456&quot;</span>);</span><br><span class="line">BigDecimal d2 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;123.45600&quot;</span>);</span><br><span class="line">System.out.println(d1.equals(d2)); <span class="comment">// false,因为scale不同</span></span><br><span class="line">System.out.println(d1.equals(d2.stripTrailingZeros())); <span class="comment">// true,因为d2去除尾部0后scale变为2</span></span><br><span class="line">System.out.println(d1.compareTo(d2)); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p><a href="https://docs.oracle.com/javase/7/docs/api/java/math/BigDecimal.html">更多BigDecimal方法戳这里</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;2013-蓝桥B-T4&quot;&gt;&lt;a href=&quot;#2013-蓝桥B-T4&quot; class=&quot;headerlink&quot; title=&quot;2013 蓝桥B T4&quot;&gt;&lt;/a&gt;2013 蓝桥B T4&lt;/h1&gt;&lt;p&gt; 题目：黄金分割数0.61803… 是个无理数，这个常数十分重要，在</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>2013蓝桥T7</title>
    <link href="http://pangdan007.github.io/2020/09/30/2013%E8%93%9D%E6%A1%A5T7/"/>
    <id>http://pangdan007.github.io/2020/09/30/2013%E8%93%9D%E6%A1%A5T7/</id>
    <published>2020-09-30T07:49:07.888Z</published>
    <updated>2020-09-30T07:53:10.844Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2013蓝桥杯T7"><a href="#2013蓝桥杯T7" class="headerlink" title="2013蓝桥杯T7"></a>2013蓝桥杯T7</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>标题：错误票据<br>某涉密单位下发了某种票据，并要在年终全部收回。<br>每张票据有唯一的ID号。全年所有票据的ID号是连续的，但ID的开始数码是随机选定的。<br>因为工作人员疏忽，在录入ID号的时候发生了一处错误，造成了某个ID断号，另外一个ID重号。<br>你的任务是通过编程，找出断号的ID和重号的ID。<br>假设断号不可能发生在最大和最小号。<br>要求程序首先输入一个整数N(N&lt;100)表示后面数据行数。<br>接着读入N行数据。<br>每行数据长度不等，是用空格分开的若干个（不大于100个）正整数（不大于100000）<br>每个整数代表一个ID号。<br>求程序输出1行，含两个整数m n，用空格分隔。<br>其中，m表示断号ID，n表示重号ID<br>例如：<br>用户输入：<br>2<br>5 6 8 11 9<br>10 12 9<br>则程序输出：<br>7 9<br>再例如：<br>用户输入：<br>6<br>164 178 108 109 180 155 141 159 104 182 179 118 137 184 115 124 125 129 168 196<br>172 189 127 107 112 192 103 131 133 169 158<br>128 102 110 148 139 157 140 195 197<br>185 152 135 106 123 173 122 136 174 191 145 116 151 143 175 120 161 134 162 190<br>149 138 142 146 199 126 165 156 153 193 144 166 170 121 171 132 101 194 187 188<br>113 130 176 154 177 120 117 150 114 183 186 181 100 163 160 167 147 198 111 119<br>则程序输出：<br>105 120</p><p>资源约定：<br>峰值内存消耗（含虚拟机） &lt; 64M<br>CPU消耗  &lt; 2000ms<br>##分析</p><ul><li>这道题恶心之处在于输入数据时要先输入一个n，需要用Scanner类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> N = sc.nextInt();</span><br></pre></td></tr></table></figure></li><li>在测试的时候，每一行的数据长度不同，因此数组长度不确定，需要设置一个ArrayList<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; arr = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 错误票据 </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> N = sc.nextInt();</span><br><span class="line">sc.nextLine();                          <span class="comment">//这里是为了吃掉第一行的换行符</span></span><br><span class="line">ArrayList&lt;Integer&gt; arr = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();   </span><br><span class="line">                             <span class="comment">//因为数组长度不确定，所以用ArrayList</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">String line = sc.nextLine();</span><br><span class="line">String[] split = line.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; split.length; j++) &#123;</span><br><span class="line">arr.add(Integer.parseInt(split[j]));         </span><br><span class="line">        <span class="comment">//split[]里的数据类型是String，需要强制转化为int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Collections.sort(arr);            <span class="comment">//对于ArrayList，排序用Collections类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//for (int i = 0; i &lt; arr.size(); i++) &#123;</span></span><br><span class="line"><span class="comment">//System.out.print(arr.get(i)+&quot; &quot;);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//System.out.println();</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a=<span class="number">0</span>,b=<span class="number">0</span>;                              <span class="comment">//局部变量需要设置初值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.size(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(arr.get(i)-arr.get(i-<span class="number">1</span>)==<span class="number">2</span>) &#123;</span><br><span class="line">a = arr.get(i)-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(arr.get(i)-arr.get(i-<span class="number">1</span>)==<span class="number">0</span>) &#123;</span><br><span class="line">b = arr.get(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.print(a+<span class="string">&quot; &quot;</span>+b);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2></li><li>对API中的常用类不熟悉，遇到问题常查API</li><li>当数据长度不确定，定义列表数组</li><li>对数组列表进行排序等操作时，调用Collections类</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;2013蓝桥杯T7&quot;&gt;&lt;a href=&quot;#2013蓝桥杯T7&quot; class=&quot;headerlink&quot; title=&quot;2013蓝桥杯T7&quot;&gt;&lt;/a&gt;2013蓝桥杯T7&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>2013蓝桥T6</title>
    <link href="http://pangdan007.github.io/2020/09/29/2013%E8%93%9D%E6%A1%A5T6/"/>
    <id>http://pangdan007.github.io/2020/09/29/2013%E8%93%9D%E6%A1%A5T6/</id>
    <published>2020-09-28T16:32:11.888Z</published>
    <updated>2020-09-28T16:43:38.630Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2013蓝桥杯T6"><a href="#2013蓝桥杯T6" class="headerlink" title="2013蓝桥杯T6"></a>2013蓝桥杯T6</h1><h2 id="三部排序"><a href="#三部排序" class="headerlink" title="三部排序"></a>三部排序</h2><p>对一个整型数组中的数字进行分类排序：使得<strong>负数都靠左端，正数都靠右端，0在中部</strong>。<br>注意问题的特点是：<br>负数区域和正数区域内并<strong>不要求有序</strong>。可以利用这个特点通过<strong>1次线性扫描</strong>就结束战斗!!</p><p>直接上代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 三部排序 </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> [] a)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> p = <span class="number">0</span>;                                   <span class="comment">//指针</span></span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>;               </span><br><span class="line"><span class="keyword">int</span> right = a.length-<span class="number">1</span>;                      <span class="comment">//这里注意要a.length-1，否则报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(p &lt;= right) &#123;      </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(a[p]&lt;<span class="number">0</span>) &#123;                           <span class="comment">//当遇到负数，与左指针交换位置</span></span><br><span class="line"><span class="keyword">int</span> t = a[left];                   <span class="comment">//为了确保交换位置后的负数不动                                   </span></span><br><span class="line">a[left] = a[p];                    <span class="comment">//且左指针以左全为负数    </span></span><br><span class="line">a[p] = t;                          <span class="comment">//左指针和p指针同时+1</span></span><br><span class="line">left++;</span><br><span class="line">p++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a[p]&gt;<span class="number">0</span>) &#123;                      <span class="comment">//当遇到正数，与右指针交换位置</span></span><br><span class="line"><span class="keyword">int</span> t = a[right];                  <span class="comment">//为避免从右指针换来的还是正数</span></span><br><span class="line">a[right] = a[p];                   <span class="comment">//p指针不动</span></span><br><span class="line">a[p] = t;</span><br><span class="line">right--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> &#123;                                 <span class="comment">//当遇到0时，p指针+1</span></span><br><span class="line">p++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;   <span class="comment">//显示每一步交换后的结果</span></span><br><span class="line">System.out.print(a[i]+<span class="string">&quot; &quot;</span>);         </span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] a = &#123;<span class="number">5</span>,<span class="number">8</span>,<span class="number">15</span>,-<span class="number">6</span>,-<span class="number">9</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">14</span>,<span class="number">9</span>&#125;;</span><br><span class="line">sort(a);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">System.out.print(a[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题本是一个填空题，但这道题也是一道<strong>快排</strong>的变形题。<br><strong>从填空题的角度</strong>，前两种情况所改变的指针分别是<strong>left</strong>和<strong>right</strong>,所以第三种应该改变指针p。<br><strong>从快速排序的角度来讲</strong>，在只考虑符号而不考虑大小时，如何利用三部排序对数组进行排序。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;2013蓝桥杯T6&quot;&gt;&lt;a href=&quot;#2013蓝桥杯T6&quot; class=&quot;headerlink&quot; title=&quot;2013蓝桥杯T6&quot;&gt;&lt;/a&gt;2013蓝桥杯T6&lt;/h1&gt;&lt;h2 id=&quot;三部排序&quot;&gt;&lt;a href=&quot;#三部排序&quot; class=&quot;headerli</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>博客从想法到实现</title>
    <link href="http://pangdan007.github.io/2020/09/16/begining/"/>
    <id>http://pangdan007.github.io/2020/09/16/begining/</id>
    <published>2020-09-16T15:16:22.911Z</published>
    <updated>2020-09-23T02:11:08.217Z</updated>
    
    <content type="html"><![CDATA[<p>早上突然有了做一个属于自己的博客的想法，于是，Just do it ！<a id="more"></a>在室友的指导加推荐之下，我先是在阿里云上注册了一个属于自己的域名，然后室友推给我<a href="https://www.jianshu.com/p/6db5c75c167b">一篇文章</a>,根据这篇文章的指导，尽管过程曲折，我最终仍然成功解析了我的域名并连接到了我的博客上，yes！</p><h2 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h2><p>博客建成之后依然存在着一些问题</p><h3 id="安全性问题"><a href="#安全性问题" class="headerlink" title="安全性问题"></a>安全性问题</h3><p>无论是用Chrome还是Microsoft Edge输入域名进入博客都显示不安全的提示</p><h3 id="post排版问题"><a href="#post排版问题" class="headerlink" title="post排版问题"></a>post排版问题</h3><p>作为纯小白表示一脸懵X，但学习的意志十分坚定！！！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;早上突然有了做一个属于自己的博客的想法，于是，Just do it ！</summary>
    
    
    
    
  </entry>
  
</feed>
